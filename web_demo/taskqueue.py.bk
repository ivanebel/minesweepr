from tornado.ioloop import IOLoop
import tornado.web as web
from tornado.httpclient import HTTPError
import sys
import json
import multiprocessing as mp
import itertools
import threading
from optparse import OptionParser

import os

def f(x):
    a = sum(xrange(1, x))
    return '-%d-' % x

def eval_task(func, args, kwargs):
    try:
        return (True, f(*args, **kwargs))
    except Exception, e:
        return (False, '%s %s' % (type(e), str(e)))

def worker_loop(inq, outq):
    while True:
        job_id, func, args, kwargs = inq.get()
        success, result = eval_task(func, args, kwargs)
        outq.put((job_id, success, result))

class Pool(threading.Thread):
    def __init__(self, num_workers):
        threading.Thread.__init__(self)
        self.lock = threading.Lock()
        self.daemon = True

        self.num_workers = num_workers
        self.job_counter = 0
        self.callbacks = {}

        self.outq = mp.Queue()
        self.inq = mp.Queue()
        self.workers = [self.make_worker() for i in range(self.num_workers)]

    def make_worker(self):
        w = mp.Process(target=worker_loop, args=[self.outq, self.inq])
        w.start()
        return w

    def apply_async(self, callback, func, args=[], kwargs={}, time_limit=None):
        job_id = self.new_job(callback)
        print '>>', job_id, args
        self.outq.put((job_id, func, args, kwargs))

    def run(self):
        while True:
            job_id, success, result = self.inq.get()
            status = {True: 'success', False: 'exception'}[success]
            with self.lock:
                callback = self.callbacks[job_id]
                del self.callbacks[job_id]
                print '<<', job_id, result
                IOLoop.instance().add_callback(lambda: callback(status, result))

    def new_job(self, callback):
        with self.lock:
            job_id = self.job_counter
            self.job_counter += 1
            self.callbacks[job_id] = callback
            return job_id

class TaskHandler(web.RequestHandler):
    def initialize(self, pool):
        self.pool = pool

    @web.asynchronous
    def post(self):
        func, args, kwargs, time_limit = self.parse_args()
        self.pool.apply_async(self._on_task_finish, func, args, kwargs, time_limit)

    def _on_task_finish(self, status, result):
        if self._finished:
            print 'fuck im finished', result
            return

        self.set_header('Content-Type', 'text/json')
        self.write(json.dumps({'status': status, 'result': result}))
        self.finish()

    def parse_args(self):
        raw_payload = self.request.body
        try:
            payload = json.loads(raw_payload)
        except ValueError:
            raise HTTPError(400, 'invalid json body')

        try:
            func = payload['method']
            args = payload.get('args', [])
            kwargs = payload.get('kwargs', {})
            time_limit = payload.get('time_limit')
        except KeyError:
            raise HTTPError(400, 'missing required arguments')

        return func, args, kwargs, time_limit

def parse_options():
    parser = OptionParser()
    parser.add_option("-p", "--port", dest="port", type='int', default=9690)
    parser.add_option("-w", "--workers", dest="num_workers", type='int', default=3)
    (options, args) = parser.parse_args()
    return options

if __name__ == "__main__":
    opts = parse_options()

    pool = Pool(opts.num_workers)
    pool.start()

    application = web.Application([
        (r'/', TaskHandler, {'pool': pool}),
    ])
    application.listen(opts.port)
    IOLoop.instance().start()
